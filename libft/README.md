# üìö Libft

> `libft` √© uma implementa√ß√£o personalizada de fun√ß√µes essenciais da biblioteca padr√£o do C,  
> complementada por utilit√°rios adicionais que servem como base para projetos futuros na 42.  
> Este projeto √© um excelente exerc√≠cio para manipula√ß√£o de mem√≥ria, strings e opera√ß√µes de baixo n√≠vel,  
> al√©m de refor√ßar conceitos fundamentais de programa√ß√£o em C.

![Banner](https://img.shields.io/badge/Project-libft-blueviolet) ![C](https://img.shields.io/badge/Language-C-red) ![License](https://img.shields.io/badge/License-MIT-green)

---

## üéØ Objetivo

O objetivo da **libft** √© criar, do zero, uma biblioteca em C contendo fun√ß√µes essenciais  
‚Äî tanto da **biblioteca padr√£o** quanto utilit√°rios extras ‚Äî para servir como  
**base s√≥lida** no desenvolvimento de projetos futuros.  

Este projeto desafia √°:
- üß† **Aprofundar** o entendimento sobre ponteiros, arrays e aloca√ß√£o din√¢mica de mem√≥ria.  
- üõ† **Reimplementar** fun√ß√µes da `libc` para compreender seu funcionamento interno.  
- üöÄ **Desenvolver** novas fun√ß√µes utilit√°rias para manipula√ß√£o de strings, mem√≥ria e listas.  
- üìö Criar um **repert√≥rio de c√≥digo reutiliz√°vel** para economizar tempo nos pr√≥ximos projetos.  

No final, voc√™ ter√° uma biblioteca **pr√≥pria**, **eficiente** e **pronta para uso.**

## ‚öôÔ∏è Funcionalidade

A **libft** fornece um conjunto de fun√ß√µes escritas em C que replicam comportamentos  
da biblioteca padr√£o e adicionam novas ferramentas √∫teis.  

Ela √© dividida em tr√™s partes principais:  
1. **Fun√ß√µes da libc** üèõ ‚Äî Implementa√ß√µes pr√≥prias de fun√ß√µes como `strlen`, `strcpy`, `memset`, etc.  
2. **Fun√ß√µes adicionais** ‚ú® ‚Äî Novas fun√ß√µes para manipula√ß√£o de strings, convers√µes e mem√≥ria.  
3. **B√¥nus (opcional)** üß© ‚Äî Manipula√ß√£o de listas encadeadas para praticar estruturas de dados.  

Com ela, voc√™ poder√°:
- üìè Medir, copiar e modificar strings.
- üîç Pesquisar caracteres e substrings.
- üßÆ Converter valores e dados.
- üóÇ Manipular blocos de mem√≥ria.
- ü™¢ Criar e gerenciar listas encadeadas.

Em resumo: a **libft** √© uma biblioteca pronta para ser inclu√≠da e  
reutilizada em qualquer projeto futuro na 42.


## üß© Conceito Trabalhado

O projeto **libft** aprofunda o contato com os fundamentos da linguagem C,  
permitindo ganhar autonomia e dom√≠nio do c√≥digo, com:

- üì¶ **Manipula√ß√£o de mem√≥ria** ‚Äî para gerenciar aloca√ß√µes, libera√ß√µes e c√≥pias de dados.  
- üß≠ **Uso de ponteiros** ‚Äî para navegar e acessar diretamente posi√ß√µes de mem√≥ria.  
- ‚úç **Tratamento de strings como arrays de caracteres** ‚Äî para manipula√ß√µes textuais em baixo n√≠vel.  
- üîÑ **Convers√£o de tipos** ‚Äî para trabalhar com diferentes formatos de dados.  
- üîç **Implementa√ß√£o de algoritmos b√°sicos** ‚Äî para busca, c√≥pia, compara√ß√£o e transforma√ß√£o de informa√ß√µes.  
- üóÇ **Organiza√ß√£o modular do c√≥digo** ‚Äî com cabe√ßalhos, arquivos `.c` e Makefile bem estruturados.  

## üìÇ Arquivos

| Arquivo/Pasta      | Descri√ß√£o                                                                 |
|--------------------|---------------------------------------------------------------------------|
| `Makefile`         | Script para compilar, recompilar e limpar a biblioteca                    |
| `srcs/part1`       | Fun√ß√µes da primeira parte (reimplementa√ß√µes da `libc`)                    |
| `srcs/part2`       | Fun√ß√µes adicionais para manipula√ß√£o de strings, mem√≥ria e convers√µes      |
| `srcs/bonus`       | Fun√ß√µes b√¥nus para manipula√ß√£o de listas encadeadas                       |
| `srcs/includes`    | Arquivos de cabe√ßalho (`.h`) com prot√≥tipos e defini√ß√µes necess√°rias       |


### üîß Como Compilar e Usar

Para compilar a **libft** e gerar o arquivo `libft.a`, utilize no terminal:
```bash
make
```
‚ôªÔ∏è Comandos √öteis

`make clean`	Remove apenas os arquivos objeto (.o)

`make fclean`	Remove os arquivos objeto e a biblioteca compilada

`make re`	Executa fclean e recompila tudo do zero

### üíª Como Usar

#### Para usar basta incluir o Header:
Inclua o arquivo de cabe√ßalho no seu c√≥digo:
```C
#include "libft.h"
```
E compilar usando a biblioteca:
```bash
make              # Compila a biblioteca e gera libft.a
gcc main.c libft.a -I ./srcs/includes
./a.out
```
> Ou alterar o Makefile para compilar junto com o seu main.c

## üìö Fun√ß√µes Implementadas na Libft ‚Äì Descri√ß√£o e Exemplos

#### üîó Parte 1.
| Fun√ß√£o       | Par√¢metros | Retorno | Descri√ß√£o curta | Exemplo de uso |
|--------------|-----------|---------|-----------------|----------------|
| `ft_atoi`    | `const char *str` | `int` | Converte string num√©rica em inteiro | `ft_atoi("42") // 42` |
| `ft_bzero`   | `void *s`, `size_t n` | `void` | Preenche `n` bytes de `s` com `0` | `ft_bzero(buf, 10)` |
| `ft_calloc`  | `size_t nmemb`, `size_t size` | `void *` | Aloca mem√≥ria e zera | `ft_calloc(5, sizeof(int))` |
| `ft_isalnum` | `int c` | `int` | Verifica se √© alfanum√©rico | `ft_isalnum('A') // 1` |
| `ft_isalpha` | `int c` | `int` | Verifica se √© letra | `ft_isalpha('z') // 1` |
| `ft_isascii` | `int c` | `int` | Verifica se √© caractere ASCII | `ft_isascii(128) // 0` |
| `ft_isdigit` | `int c` | `int` | Verifica se √© d√≠gito | `ft_isdigit('5') // 1` |
| `ft_isprint` | `int c` | `int` | Verifica se √© imprim√≠vel | `ft_isprint('\n') // 0` |
| `ft_memchr`  | `const void *s`, `int c`, `size_t n` | `void *` | Encontra 1¬™ ocorr√™ncia de `c` em `s` | `ft_memchr("abc", 'b', 3)` |
| `ft_memcmp`  | `const void *s1`, `const void *s2`, `size_t n` | `int` | Compara blocos de mem√≥ria | `ft_memcmp("abc","abd",3)` |
| `ft_memcpy`  | `void *dest`, `const void *src`, `size_t n` | `void *` | Copia `n` bytes de `src` para `dest` | `ft_memcpy(buf1, buf2, 5)` |
| `ft_memmove` | `void *dest`, `const void *src`, `size_t n` | `void *` | Copia mem√≥ria com sobreposi√ß√£o segura | `ft_memmove(buf+1, buf, 5)` |
| `ft_memset`  | `void *s`, `int c`, `size_t n` | `void *` | Preenche mem√≥ria com valor `c` | `ft_memset(buf, 'A', 5)` |
| `ft_strchr`  | `const char *s`, `int c` | `char *` | Encontra 1¬™ ocorr√™ncia de `c` na string | `ft_strchr("hello",'e')` |
| `ft_strdup`  | `const char *s` | `char *` | Duplica string (aloca nova) | `ft_strdup("42")` |
| `ft_strlcat` | `char *dst`, `const char *src`, `size_t size` | `size_t` | Concatena strings com limite de tamanho | `ft_strlcat(buf,"abc",10)` |
| `ft_strlcpy` | `char *dst`, `const char *src`, `size_t size` | `size_t` | Copia string com limite de tamanho | `ft_strlcpy(buf,"abc",10)` |
| `ft_strlen`  | `const char *s` | `size_t` | Retorna tamanho da string | `ft_strlen("42") // 2` |
| `ft_strncmp` | `const char *s1`, `const char *s2`, `size_t n` | `int` | Compara at√© `n` caracteres | `ft_strncmp("abc","abd",2)` |
| `ft_strnstr` | `const char *haystack`, `const char *needle`, `size_t len` | `char *` | Busca substring em tamanho limitado | `ft_strnstr("abcde","cd",5)` |
| `ft_strrchr` | `const char *s`, `int c` | `char *` | Encontra √∫ltima ocorr√™ncia de `c` | `ft_strrchr("banana",'a')` |
| `ft_tolower` | `int c` | `int` | Converte caractere para min√∫sculo | `ft_tolower('A') // 'a'` |
| `ft_toupper` | `int c` | `int` | Converte caractere para mai√∫sculo | `ft_toupper('a') // 'A'` |

#### üîó Parte 2.
| Fun√ß√£o | Par√¢metros | Retorno | Descri√ß√£o curta | Exemplo de uso |
|--------|-----------|---------|-----------------|----------------|
| `ft_itoa` | `int n` | `char *` | Converte inteiro em string (aloca nova) | `ft_itoa(42); // "42"` |
| `ft_putchar_fd` | `char c`, `int fd` | `void` | Escreve caractere no file descriptor | `ft_putchar_fd('A', 1);` |
| `ft_putendl_fd` | `char *s`, `int fd` | `void` | Escreve string + `\n` no file descriptor | `ft_putendl_fd("Hello", 1);` |
| `ft_putnbr_fd` | `int n`, `int fd` | `void` | Escreve n√∫mero no file descriptor | `ft_putnbr_fd(42, 1);` |
| `ft_putstr_fd` | `char *s`, `int fd` | `void` | Escreve string no file descriptor | `ft_putstr_fd("Hello", 1);` |
| `ft_split` | `const char *s`, `char c` | `char **` | Divide string em substrings usando `c` como delimitador | `ft_split("a,b,c", ',');` |
| `ft_striteri` | `char *s`, `void (*f)(unsigned int, char*)` | `void` | Aplica fun√ß√£o `f` a cada caractere, passando √≠ndice | `ft_striteri(str, f);` |
| `ft_strjoin` | `char const *s1`, `char const *s2` | `char *` | Junta duas strings em uma nova (alocada) | `ft_strjoin("Hello", "World");` |
| `ft_strmapi` | `char const *s`, `char (*f)(unsigned int, char)` | `char *` | Aplica `f` a cada caractere e retorna nova string | `ft_strmapi("abc", f);` |
| `ft_strtrim` | `char const *s1`, `char const *set` | `char *` | Remove do in√≠cio/fim caracteres de `set` | `ft_strtrim(" 42 ", " ");` |
| `ft_strrstr` | `const char *haystack`, `const char *needle` | `char *` | **(n√£o faz parte padr√£o, mas parece busca reversa)** | *(depende da implementa√ß√£o)* |
| `ft_substr` | `char const *s`, `unsigned int start`, `size_t len` | `char *` | Retorna substring a partir de `start` com tamanho `len` | `ft_substr("Hello", 1, 3); // "ell"` |


#### üîó B√¥nus ‚Äì Manipula√ß√£o de Listas Ligadas (t_list)
| Fun√ß√£o | Par√¢metros | Retorno | Descri√ß√£o curta | Exemplo de uso |
|--------|-----------|---------|-----------------|----------------|
| `ft_lstnew` | `void *content` | `t_list *` | Cria novo n√≥ com `content` e `next = NULL` | `t_list *n = ft_lstnew("Oi");` |
| `ft_lstadd_front` | `t_list **lst`, `t_list *new` | `void` | Adiciona n√≥ `new` no in√≠cio da lista | `ft_lstadd_front(&lst, new);` |
| `ft_lstadd_back` | `t_list **lst`, `t_list *new` | `void` | Adiciona n√≥ `new` no final da lista | `ft_lstadd_back(&lst, new);` |
| `ft_lstsize` | `t_list *lst` | `int` | Retorna quantidade de n√≥s na lista | `ft_lstsize(lst);` |
| `ft_lstlast` | `t_list *lst` | `t_list *` | Retorna √∫ltimo n√≥ da lista | `ft_lstlast(lst);` |
| `ft_lstdelone` | `t_list *lst`, `void (*del)(void *)` | `void` | Libera n√≥ usando fun√ß√£o `del` no conte√∫do | `ft_lstdelone(node, free);` |
| `ft_lstclear` | `t_list **lst`, `void (*del)(void *)` | `void` | Remove e libera todos os n√≥s | `ft_lstclear(&lst, free);` |
| `ft_lstiter` | `t_list *lst`, `void (*f)(void *)` | `void` | Aplica fun√ß√£o `f` em cada conte√∫do da lista | `ft_lstiter(lst, print);` |
| `ft_lstmap` | `t_list *lst`, `void *(*f)(void *)`, `void (*del)(void *)` | `t_list *` | Cria nova lista aplicando `f` a cada conte√∫do | `ft_lstmap(lst, dup, free);` |

##### üìå Observa√ß√µes:

Todas essas fun√ß√µes usam a estrutura t_list definida no cabe√ßalho da libft, geralmente assim:
```c
typedef struct s_list {
    void            *content;
    struct s_list   *next;
} t_list;
```
Os exemplos s√£o apenas ilustrativos e assumem que lst j√° foi criada corretamente.

---

## üë©‚Äçüíª Autoria

**‚ú® Amy Rodrigues ‚ú®** 

üéì Estudante de C e desenvolvimento de baixo n√≠vel na [42 S√£o Paulo](https://www.42sp.org.br/)

üêß Usu√°ria de Linux | üíª F√£ de terminal | üéØ Apaixonada por entender como tudo funciona por tr√°s dos bastidores

---

## üìé Licen√ßa

Este projeto foi desenvolvido como parte do curr√≠culo educacional da 42 S√£o Paulo.

üìò **Uso permitido**:
- Pode ser utilizado como refer√™ncia para estudos e aprendizado individual
- Pode servir de inspira√ß√£o para seus pr√≥prios projetos

üö´ **Proibido**:
- Submeter c√≥pias deste projeto como se fossem de sua autoria em avalia√ß√µes da 42 ou outras institui√ß√µes

Seja √©tico e contribua para uma comunidade de desenvolvedores mais honesta e colaborativa ü§ù
